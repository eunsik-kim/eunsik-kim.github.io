---
title: A tour of Computer Systems
author: eunsik-kim
date: 2024-03-18 02:30:00 +0900
categories: [book, Computer Systems]
tags: cs
render_with_liquid: false
---

Bryant, Randal E의 [Computer Systems](https://product.kyobobook.co.kr/detail/S000003155432)의 내용을 공부목적으로 기억할 부분을 요약한 글입니다. 추가적으로 나름대로 저만의 의문이나 문제들을 추가하려 합니다.

Q) Computer system은 뭘까요?  

다음과 같은 낯익은 hello.c 파일이 존재한다고 생각해봅시다.
```
#include <stdio.h>

int main(){
  printf("hello, World\n");
  return 0;
}
```
{: file='hello.c'}

1. 이 파일의 존재 방식과 2. 이 파일이 실행되는 과정에 대해 간략하게 알아 보고 3. 그와 더불어 실행을 처리하는 컴퓨터 시스템 구성요소에 대해 간단히 알아 보겠습니다.

### 정보는 비트와 컨텍스트로 이루어진다

컴퓨터가 정보를 저장할 때 당연히 숫자로 저장할 것 같습니다. 그래서 흔히 많이 사용되는 `아스키(ASCII)` 표준을 사용하여 표시한다고 합니다.
평소에 enter키나 space를 많이 누르는 분들은 컴퓨터 용량을 걱정하셔야 될것 같습니다.

> \#  i   n   c  l    u   d   e  SP  \<  s   t   d   i   o   .  h  \> \n   
> 35 105 110 99 108  117 100 101 32  60 115 116 100 105 111 46 104 62 10

위에서 변환된는 것 처럼 아스키 문자들로만 이루어진 파일을 `텍스트 파일`, 그 이외의 파일들을 `바이너리 파일`이라고 지칭합니다.
그럼 바이너리 파일은 어떻게 저장되는 걸까요? 컴퓨터가 처리하기 적합한 형태이기 때문에 바이너리 파일들은 말그대로 2진법으로 저장됩니다. 

`컨택스트`는 이 비트이 나열이 어떤 의미를 가지고 어떻게 해석해야 되는지 판다하는 요소입니다. 같은 숫자라도 파일읽는 방식에 따라 달라지겠죠.
그럼 이 파일이 어떤 식으로 읽을 수 있게 되는지 알아보도록 하겠습니다.

### 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

hello 프로그램은 인간이 읽을 수 있으므로 고급 프로그램에 해당됩니다. 하지만 이 프로그램을 기계가 읽고 실행가능하도록 하려면 언어를 바꿔야겠죠? 이 과정을 `컴파일 시스템`이라고 합니다. 소스프로그램을 실행하기 위해 각 pre-processor, Complier, Assembler, linker가 뒤에서 묵묵히 열일하고 있다는 것을 알아야 합니다.

##### 1. Pre-processor(cpp)  
pre-processor는 Source program인 hello.c를 hello.i로 변환합니다. #include와 같은 헤더의 내용을 삽입합니다.
##### 2. Complier(cc1)  
Complier는 변형된 Source program인 hello.i를 hello.s로 변환합니다. 저수준 Assembly어로 바꾸는 과정을 거칩니다. 이러면 모든 언어들은 기계어와 호환이 될 수 있으므로 효과적인 절차라고 볼 수 있습니다.

이전까지는 언어였으므로 변환된 파일은 text파일입니다. 3번 4번에 나오는 생성된 파일은 컴퓨터가 실행해야 하는 파일이므로 위에서 배웠듯 종류는 binary 파일입니다. 

##### 3. Asssembler(as)  
Asssembler는 hello.s를 hello.o로 바꿉니다. (책에서 hello.o가 재배치 가능한 목적 프로그램이라는데 relocatbale object는 객체로 해석해야 되지않을까라고 생각합니다. 따라서 object로 표기하겠습니다.)

##### 4. linker(ld)  
linker는 hello.o를 실행가능한 파일로 바꿉니다. (저는 hello.exe라고 생각하지만 책에서는 hello라고 적어두네요 편의상 hello.exe라고 하겠습니다.) printf함수를 호출하기 위해 다른 object 파일에서 가져와 재배치하여 pritnf가 실행되도록 하는 절차 입니다. printf를 사용하기위해 코드가 작성되는 구조는 효율적이라고 판단되지만, 가져오는 과정이나 linker를 사용하기 위해 파일들을 구성하면서 이해하기 힘든 복잡한 에러가 발생할 수 있다고 합니다.

위의 절차를 앞으로 자세하게 익혀 최적화 하는방법을 배울 수 있기를 기대합니다. 다음으로는 hello.exe 파일을 어떻게 실행하는지 알아보겠습니다.

> ##### UNIX와 C언어
  처음에 만들어진 운영체제는 OS/360 과 Multic와 같이 거대하고 복잡한 운영체제로 존재하였습니다. 하지만 multics를 만들던 사람들이 짜증나서(?) 그에 대응하는 작고 simple한 Unix라는 OS가 만들어지고 그 Unix를 만들기 위해 C언어를 설계하였다고 합니다. 이후 Unix를 잘쓰기 위해 Posix라는 유닉스 규격도 생겼다고 해요.
{: .prompt-info }

### 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.

쉘이라는 응용프로그램을 써보셨을 것입니다. 혹시 파일을 실행하는 원리에 대해서 아시나요? 아래와 같은 방식으로 동작합니다. 단순하죠?
```
if (명령어 라인 == 쉘내장 명령어){
  명령어를 실행
} else {
  파일을 실행
}
```
{: file='Unix kernel code'}

hello.exe의 실행과정을 설명에 앞서 이해를 돕기 위해 인텔 계열의 시스템 하드웨어에서 각 요소들에 대해 설명하겠습니다.
1. 버스들(Buses)  
버스가 정해진 경로 속에서 사람들을 나르는 것처럼 시스템의 내부에서 word(고정크기의 약 4 or 8 byte정도하는 word들을)들을 주고받으며 소통합니다. 
2. 입출력장치(I/O)   
입출력 장치는 외부세계와의 연결을 담당합니다. keyboard, mouse, display, network, ... 여러가지가 있겠네요.
3. 메인메모리(main memory)
프로세서가 실행되는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치입니다. 물리적으로 DRAM칩들로 구성되어 있습니다. 논리적으로는 연속적인 바이트의 배열로 고유의 주소를 가지고 있는 저장공간입니다.
4. 프로세서(CPU)
main memory에 저장된 instruction을 해독하고 실행하는 장치입니다. register(word 크기의 저장장치)의 하나인 PC(program counter)는 메인메모리에 저장된 insturction을 가리킵니다.(명령어 포인터라고 생각하면 된다.) 그래서 PC를 따라 main memory에 위치한 instruction을 찾고 실행하는 과정을 반복합니다. 다음은 CPU가 실행하는 작업들입니다. 모든 저장은 덮어쓰는 방식으로 진행됩니다.
- 적재(Load): main memory > register 로 복사
- 저장(Store): register > main memory 로 복사
- 작업(Operate): 두 레지스터의 값을 ALU(수식/논리 처리기)로 복사 > 수식연산 한뒤 register에 복사
- 점프(Jump): instruction에 의해 자신의 워드를 다시 PC에 저장 

이제 hello 프로그램을 실행해 보겠습니다. 사람이 사물을 판단하고 의사를 결정하는 행동과 거의 동일합니다.

1. hello 파일을 keyboard로 입력합니다. > bus를 따라 CPU register에 도착합니다. > 저장 instruction에 의해 memory에 정보가 저장됩니다.
2. enter를 누르면 파일을 실행하라는 명령이 전달됩니다. > hello를 disk에서 main momory로 로딩합니다. (여기서 DMA를 통해 CPU를 거치지 않고 직접 이동합니다. 위의 로딩과 다른 표현이지만 같은 맥락인것 같습니다.)
3. 결과 string을 main memory에서 register로 로딩합니다. > display에 띄우며 명령이 종료가 됩니다.

위의 보이는 과정에서 cpu가 주된 명령을 하달하며 정보들을 생각보다 많이 이동시키는 과정을 확인할 수 있습니다.

### 캐시가 왜 중요할까?

위의 과정들에서 정보를 이동하는것에 많은 오버해드가 발생함을 알 수 있습니다. 그래서 우리는 캐시메모리를 만들어 작지만 빠른 저장장치를 활용하여 자주쓰는 명령어와 정보를 저장해 처리 효율을 높여야 됩니다. 하지만 메모리 제조사는 메모리라는 저장장치의 특성인 비용과 크기, 속도의 문제로 인해 가장 효율좋은 메모리를 구성하는데 어려움을 겪는다는 사실을 알 수 있습니다. (삼성 화이팅) 

이것을 효과적으로 처리하기 위해 메모리를 6단계 계층으로 나눠 사용합니다. 각 메모리는 서로의 캐시 메모리의 역할을 합니다. 메모리들의 속도로 구분해 보면 register \>\>\> cache(L1, L2, L3) \>\>\> main memory \>\>\> disk \>\>\> remote storge 인것을 알 수 있습니다. 메모리 저장장치가 느리다고 안쓰는것도 아니고, 많이 저장할 수 있다고 많이 쓰는것도 아닌것으로 보아 모두가 자기의 역할과 몫이 존재한다는 사실을 알 수 있습니다.

> SRAM 과 DRAM의 차이에 대해 알아보겠습니다. SRAM은 가격이 비싸고 속도가 빠르지만 공간을 많이 차지하여 캐시메모리에 사용됩니다. 그리고 저장된 정보를 전원이 공급하는한 내용을 유지하는 특성을 가집니다. DRAM은 속도가 SRAM보다는 느리지만 구조가 간단하여 집적도가 높습니다. 가격도 저렴하여 메인메모리의 저장장치로 많이 사용되고 있습니다.
{: .prompt-info }

### 운영체제는 하드웨어를 관리한다.

hello파일을 실행할 때 사람과 동일하게 행동한다고 했습니다. 음식을 먹을 때 턱근육을 사용해 입을 벌리던가, 읽어서기 위해 다리 근육을 사용하는 것처럼 하드웨어 장치들을 적절히 조율하는 시스템이 존재하는데 그것이 바로 운영체제 입니다. 운영체제(OS)는 1. 제멋대로 동작하는 app들이 잘못사용되는 것을 막고 2. 하드웨어들을 균일한 메커니즘으로 동작하기 위해 존재합니다. (app들은 지식들에 해당되겠네요) 

위와 같은 두가지 목표를 달성하기위해 다음과 같은 추상화를 통해 달성 하고 있습니다. 각 요소들을 설명하면서 이해해보도록 하겠습니다.
> I/O device : files
> Virtual memory : main memory + files
> Instruction set architecture : > processor
> Procesess : processor + main memory + files
> Virtual machine : operating system + processor + main memory + files
> 컴퓨터 과학에서 `추상화(abstraction)`는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말합니다.

{: .prompt-info }

0. 가상머신
가상머신은 운영체제, 프로세서, 프로그램모두를 포함하는 컴퓨터 전체의 추상화 입니다. 가상머신을 통해 우리는 window에서도 linux(wsl)를 실행 할 수 있습니다. 

1. 프로세스 
프로세스는 실행중인 프로그램에 대한 운영체제의 추상화 입니다. 각 processor와 main memory 그리고 file들이 합쳐 하나의 프로그램을 운영하고 있음을 알 수 있습니다. 심지어 다수의 프로그램은 동시성을 유지하며 베타적으로 하드웨어를 사용하게 하는 착각을 일으킵니다. 어떻게 그런일이 가능한 걸까요?

운영체제는 `문맥전환context switching`을 통해 다수의 프로세스를 교차실행합니다. 여기서 context는 프로세스를 실행하는데 필요한 모든정보(PC, register 파일, 메인 메모리의 현재 값)을 의미하고 이것을 바꿔 가며 새로운 프로세스로 전환을 합니다. 각 프로세스는 전환을 운영체제에 요청할 때 `시스템 콜`이라는 특수함수를 통해 운영체제로 제어권을 넘겨줍니다. 그럼 시스템 콜을 처리하는 운영체제의 일부분인 `kernel`에 의해 제어가 됩니다. 

> kernel은 프로세스가 아니라 모든 프로세스를 관리 하기 위해 시스템이 이용하는 코드와 자료구조의 집합입니다.
{: .prompt-info }

프로세스가 한개의 흐름인것 같지만 사실 수많은 thread라는 다수의 실행 유닛으로 구성되어 있습니다. thread들은 프로세스보다 자원 공유가 더 쉽기 때문에 프로그램 속도를 높이기 위해 다중 쓰레딩을 활용합니다.

2. 인스트럭션 집합구조
인스트럭션 집합 구조는 실제 프로세서 하드웨어의 추상화를 제공하는 것입니다. 이를 통해 복잡한 기계어를 단순한 인스트력션 통해 실행될 수 있습니다.

3. 가상메모리
가상메모리는 각 프로세스들이 메인메모리 전체를 독점적으로 사용하고 있는것 같은 환상을 주는 추상화 입니다. 각 프로세스는 가상주소 공간을 가지며 균일한 메모리의 모습을 가지게 됩니다. 데이터들을 하드웨어의 주소와 연결하는 복잡한 과정이 수반됩니다. 간단히 생각하면 프로세스의 데이터를 메인메모리의 캐시를 활용하여 저장합니다.
- 프로그램 코드와 데이터 : 전역변수에 해당하는 데이터의 위치
- 힙 : 코드 동작시 생성되는 동적 메모리
- 공유 라이블러리 : stdio.c 나 cmath같은 코드의 데이터
- 스택 : 힙과 유사하지만 함수 호출시 사용되는 동적 메모리
- 커널 가상메모리 : 커널만 사용가능한 공간, 다른 프로그램은 접근불가

4. 파일
파일은 연속된 바이트열이며 모든 시스템의 대화수단이기도 합니다. 다양한 입출력장치의 통일된 대화 수단을 유지할 수 있도록 해줍니다. 덕분에 저희는 하드디스크에 접근할 때 파일을 통해 저장을 하거나 읽기가 가능합니다.


### 네트워크를 통해 다른시스템에 연결될 수 있습니다.

네트워크는 디스크에 접근하여 파일을 가져오는것과 동일한 원리로 작동됩니다. OS에 명령을 내리면 I/O bus를 통해 network adapter에 데이터를 요청하는 명령을 전달합니다. 그럼 원격 서버로부터 데이터를 전송 받게 되고 해당하는 명령이나 데이터가 메인메모리에 적재 됩니다.


### 멀티코어 시스템

컴퓨터의 연산 성능을 높이기 위해 단일 코어를 한계치 이상으로 실행하면 많은 발열과 전력이 소모가 됩니다. 그래서 동시성과 병렬성을 활용하는 멀티 코어 시스템을 도입되었습니다. 추상화된 개념인 멀티 쓰레드를 실행하기 위한 하드웨어의 멀티코어 시스템에 대해 간단히 알아보겠습니다. 프로세서 칩에는 여러개의 CPU 코어를 가지고 있으며 각 코어는 L1, L2 캐시 메모리를 가지고 있고 메인메모리와 캐시를 공유합니다. 각 코어가 2개의 쓰레드를 병렬로 실행할 수 있습니다. 그래서 만약 4개의 코어가 존재한다면 8가지의 쓰레드를 실행가능하게 합니다.


#### 남은 것?
컴퓨터 시스템은 프로그램을 실행하기 위한 소프트웨어와 하드웨어로 구성됩니다. 프로그램은 하드웨어 위에서 여러 프로그램에 의해 기계어로 번역이 되어 실행이 됩니다. CPU에의해 하드웨어가 동작하는 과정을 훝었고 사람과 유사하게 동작한다는 것을 확인했습니다. 그리고 운영체제가 하드웨어를 관리하기 위해 컴퓨터가 실행하며 생기는 추상화된 개념을 보았습니다. 아직은 배경지식도 부족하여 깊게 이해못하였지만 다음 챕터부턴 추상화된 정보가 아닌 구체화된 지식을 다루도록 하겠습니다.